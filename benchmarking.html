<!-- 
  Student: Ben Adams
  Course: CS81 JavaScript
  Instructor: Professor Seno 
-->

<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-gH2yIJqKdNHPEq0n4Mqa/HGKIhSkIHeL5AyhkYV8i59U5AR6csBvApHHNl/vI1Bx" crossorigin="anonymous">
    <title></title>
  </head>
  <body>
    <div class="container">
      <h1>Time Complexity</h1>
      <blockquote>
        <p> Time complexity is the computational complexity that describes how long the computer takes to run an algorithm. Time complexity counts the number of elementary operations that the algorithm carries out. 
          We suppose that each operation takes some constant fixed amount of time. Then, we say that the amount of time taken and the number of operations are related by some constant factor. The most common case is to consider
          worst case time complexity, although in some applications it might make sense to consider the average case complexity or even the best case complexity. We consider the asymptotic behavior of the complexity as the input size increases. 
          Big O Notation is used to express this complexity, where 'n' is taken to be the number of bits used to represent the input.<br/><br/>
          
          A constant time algorithm is bounded by a value that does not depend on the size of the input. For example, a single comparison or a single data access take constant time. <br/><br/>
    
          A linear time algorithm has complexity that increases linearly with the size of the input. An example of a linear time algorithm would be looping over each element in an array to find the largest or smallest.  <br/><br/>
    
          A polynomial time algorithm is upper-bounded by a polynomial expression in the size of the input. A polynomial time algorithm would be something like Bubble Sort. Note that Bubble Sort uses a nested loop to iterate over an array. <br/><br/>
    
          A log-linear time algorithm runs faster than a polynomial time algorithm and slower than a linear time algorithm. An example would be the Merge Sort or Heap Sort algorithm. Note that both make log(n) calls, each of which performs at most O(n) work.
    </p>
      </blockquote>
    </div>
    <div class="accordion" id="accordionExample">
      <div class="accordion-item">
        <h2 class="accordion-header" id="headingOne">
          <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapseOne" aria-expanded="true" aria-controls="collapseOne">
            Heap Sort
          </button>
        </h2>
        <div id="collapseOne" class="accordion-collapse collapse" aria-labelledby="headingOne" data-bs-parent="#accordionExample">
          <div class="accordion-body">
              Heap sort is a comparison based sorting algorithm that is performed on the heap data structure. A heap is a complete binary tree. We have min-heaps and max-heaps. 
              A min-heap has the property that the root element is the smallest and each node is less than or equal to its children. Using helper functions bubbleUp and bubbleDown 
              we can maintain this property. By repeatedly deleting and storing an element from the root, we can sort the elements. A heap is an array based implementation with a 
              logical tree representation. As such, it has O(nlogn) time complexity.
          </div>
        </div>
      </div>
      <div class="accordion-item">
        <h2 class="accordion-header" id="headingTwo">
          <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseTwo" aria-expanded="false" aria-controls="collapseTwo">
            Merge Sort
          </button>
        </h2>
        <div id="collapseTwo" class="accordion-collapse collapse" aria-labelledby="headingTwo" data-bs-parent="#accordionExample">
          <div class="accordion-body">
            Merge Sort is a comparison based sorting algorithm that utilizes the divide-and-conquer paradigm. That is, the algorithm recursively divides the array in half
              until it can no longer be divided. Then, it compares and combines the the results in sorted order. This can best be represented with an example.
              <pre><br/>
                [10, 20, 27, 9, 21, 11, 39, 50] 
                           /      \
                [10, 20, 27, 9] [21, 11, 39, 50] 
                   /       \         /     \
                [10, 20] [27, 9] [21, 11] [39,50]
                  /   \     /  \    /  \     /   \
                [10] [20] [27] [9] [21] [11] [39] [50]
                  \   /     \  /     \  /     \  /
                [10, 20] [9, 27] [11, 21] [39, 50] 
                    \      /        \       /
                [9, 10, 20, 27] [11, 21, 39, 50] 
                         \            /
                [9, 10, 11, 20, 21, 27, 39, 50]
              </pre>
              Merge Sort makes log(n) calls and the merge procedure takes O(n) time. Hence, we have O(nlogn) time complexity. 
          </div>
        </div>
      </div>
      <div class="accordion-item">
        <h2 class="accordion-header" id="headingThree">
          <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseThree" aria-expanded="false" aria-controls="collapseThree">
            Bubble Sort
          </button>
        </h2>
        <div id="collapseThree" class="accordion-collapse collapse" aria-labelledby="headingThree" data-bs-parent="#accordionExample">
          <div class="accordion-body">
              Bubble Sort is a comparison based sorting algorithm that repeatedly swaps adjacent elements if they are in the wrong order. The algorithm is named for the way the 
              larger elements bubble to the top of the list. This algorithm performs poorly for large lists. Given that it uses a nested loop to iterate, this algorithm has O(n^2) time complexity.  
          </div>
        </div>
      </div>
    </div> <br/><br/>

    <div id="plot"></div>

    <button id="runAll" type="button" onclick="runner(this.id)" class="btn btn-success">Benchmark All Algorithms</button>
    <button id="runHeapAndMerge" type="button" onclick="runner(this.id)" class="btn btn-success">Benchmark Heap and Merge Sort Algorithms</button>

    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.5/dist/umd/popper.min.js" integrity="sha384-Xe+8cL9oJa6tN/veChSP7q+mnSPaj5Bcu9mPX5F5xIGE0DVittaqT5lorf0EI7Vk" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/js/bootstrap.min.js" integrity="sha384-ODmDIVzN+pFdexxHEHFBQH3/9/vQ9uori45z4JjnFsRydbmQbmL5t1tQ0culUzyK" crossorigin="anonymous"></script>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="runner.js"></script>
  </body>
</html>